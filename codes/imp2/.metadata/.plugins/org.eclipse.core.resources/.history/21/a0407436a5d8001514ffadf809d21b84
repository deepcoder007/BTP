/*
 * configNode.cpp
 *
 *  Created on: 21-Feb-2016
 *      Author: vibhanshu
 */
// Implements the configNode Structure
#include"configNode.h"
#include<cstring>
#include<cstdlib>

// The invalid constructor of the base class
configNode::configNode(Graph* g,int rPos,int vLen,int* vPos,configNodeStorage* stor)
{
    cerr<<"[configNode] : This object should not be initialized "<<endl;
    exit(-1);
}

// The constructor, non-trivial
configNodeNaive::configNodeNaive(Graph* g,int rPos,int vLen,int* vPos,configNodeStorage* stor)
{
    vacant_length = vLen;
    vacant = new int[vacant_length];
    roboPos = rPos;
    g_ptr = g;
    storage = stor;

    key.first= rPos % HASH_KEY1_SZ;
    key.second = 0;
    vacCnt = 0;
    // simply copy the array
    int i,j;
    for(  i = 0 ; i<vacant_length ; i++ )    // 0 means an obstacle
    	for( j=0 ; j<INT_BIT_SZ; j++ )
    		if( (vacant[i] & (1<<j)) != 0  ) {
    			vacCnt++;
    			key.second += (i*INT_BIT_SZ+j) ;
    		}
    key.second %= HASH_KEY2_SZ;
}

// For permanently removing the configNode
configNodeNaive::~configNodeNaive()
{
    g_ptr = NULL;
    delete[] vacant;
    storage = NULL;
}

bool configNodeNaive::isGPU() {
	return false;
}

// Returns the position of the robot
int configNodeNaive::getRobotPos()
{
    return roboPos;
}

// Check if the node is vacant
bool configNodeNaive::isVacant(int pos)
{
    return (vacant[pos/INT_BIT_SZ] & (1<<(pos%INT_BIT_SZ)) );
}

// Returns the number of vacant nodes excluding that occupying the robot
int configNodeNaive::cntVacant()
{
    return vacCnt;
}

// Returns the number of nodes in the underlying graph
int configNodeNaive::cntNodes() {
	return g_ptr->cntNodes();
}

// Move the robot from one pos to another
// TODO: Redo this function
configNode* configNodeNaive::robotMove(int pos1,int pos2)
{
    if( g_ptr->isConnected(pos1,pos2) && isVacant(pos2) ) {
    	int* tmpArr=new int[vacant_length];
    	memcpy(tmpArr,vacant,sizeof(int)*vacant_length)

    	configNode* tmpNode = storage->getConfigNode(g_ptr,)
		return tmpNode;
    } else {
        return NULL;
    }
}

// Move the obstacle from one pos to other
// TODO: Redo this function
configNode* configNodeNaive::obsMove(int pos1,int pos2)
{
    if( g_ptr->isConnected(pos1,pos2) && isVacant(pos2) {

    	// Write here

    } else {
        return NULL;
    }
}

// Returns the 2D key of the current node
key_ii configNodeNaive::getCode()
{
	return this->key;
}

bool configNodeNaive::unCacheMe()
{

}







