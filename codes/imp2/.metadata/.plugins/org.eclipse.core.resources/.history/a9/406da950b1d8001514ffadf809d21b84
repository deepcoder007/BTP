/*
 * configNode.cpp
 *
 *  Created on: 21-Feb-2016
 *      Author: vibhanshu
 */
// Implements the configNode Structure
#include"configNode.h"
#include<cstring>
#include<cstdlib>

// The invalid constructor of the base class
configNode::configNode(Graph* g,int rPos,int vLen,int* vPos,configNodeStorage* stor)
{
    cerr<<"[configNode] : This object should not be initialized "<<endl;
    exit(-1);
}

// The constructor, non-trivial
configNodeNaive::configNodeNaive(Graph* g,int rPos,int vLen,int* vPos,configNodeStorage* stor)
{
    vacant_length = vLen;
    vacant = new int[vacant_length];
    roboPos = rPos;
    g_ptr = g;
    storage = stor;

    key.first= rPos % HASH_KEY1_SZ;
    key.second = 0;
    vacCnt = 0;
    // simply copy the array
    int i,j;
    for(  i = 0 ; i<vacant_length ; i++ )    // 0 means an obstacle
    	for( j=0 ; j<INT_BIT_SZ; j++ )
    		if( (vacant[i] & (1<<j)) != 0  ) {
    			vacCnt++;
    			key.second += (i*INT_BIT_SZ+j) ;
    		}
    key.second %= HASH_KEY2_SZ;
}

// For permanently removing the configNode
configNodeNaive::~configNodeNaive()
{
    g_ptr = NULL;
    delete[] vacant;
    storage = NULL;
}

bool configNodeNaive::isGPU() {
	return false;
}

// Returns the position of the robot
int configNodeNaive::getRobotPos()
{
    return roboPos;
}

// Check if the node is vacant
bool configNodeNaive::isVacant(int pos)
{
    return (vacant[pos/INT_BIT_SZ] & (1<<(pos%INT_BIT_SZ)) );
}

// Returns the number of vacant nodes excluding that occupying the robot
int configNodeNaive::cntVacant()
{
    return vacCnt;
}

// Returns the number of nodes in the underlying graph
int configNodeNaive::cntNodes() {
	return g_ptr->cntNodes();
}

// Move the robot from one pos to another
// TODO: Redo this function
configNode* configNodeNaive::robotMove(int pos1,int pos2)
{
    if( g_ptr->isConnected(pos1,pos2) && isVacant(pos2) ) {
    	int* tmpArr=new int[vacant_length];
    	memcpy(tmpArr,vacant,sizeof(int)*vacant_length);
    	configNode* tmpNode = storage->getConfigNode(g_ptr,pos2,vacant_length,vacant);
		delete[] tmpArr;
    	return tmpNode;
    } else {
        return NULL;
    }
}

// Move the obstacle from one pos to other
// TODO: Redo this function
configNode* configNodeNaive::obsMove(int pos1,int pos2)
{
	// check if (pos1->pos2) , if pos2 is vacant and pos1
	// is filled simultaneously
    if( g_ptr->isConnected(pos1,pos2) &&
    		isVacant(pos2) && !isVacant(pos1) )
    {
    	int* tmpArr=new int[vacant_length];
    	memcpy(tmpArr,vacant,sizeof(int)*vacant_length);
    	int i,j;
    	i = pos1 / INT_BIT_SZ;
    	j = pos1 % INT_BIT_SZ;
    	tmpArr[i] = (tmpArr[i] & ~(1<<j)) ;
    	i = pos2 / INT_BIT_SZ;
    	j = pos2 % INT_BIT_SZ;
    	tmpArr[i] = (tmpArr[i] + (1<<j))

    } else {
        return NULL;
    }
}

// Returns the 2D key of the current node
key_ii configNodeNaive::getCode()
{
	return this->key;
}








