/*
 * configNodeStorage.cpp
 *
 *  Created on: 21-Feb-2016
 *      Author: vibhanshu
 */
/*
    Implementation of the configuration node storage structures
*/
#include"configNodeStorage.h"
#include"configNode.h"

/*
    The function that should not be invoked
*/
configNodeStorage::configNodeStorage(Graph* g)
{
    cout<<"[configNodeStorage]: This class should not be initialized"<<endl;
    exit(-1);
}

configNodeStorageNaive::configNodeStorageNaive(Graph* g)
{
    int i,j;
    graph = g;
    for( i=0 ; i<HASH_KEY1_SZ ; i++ )
        for( j=0 ; j<HASH_KEY2_SZ ; j++ )
            dt[i][j]=new linkList;
}

configNodeStorageNaive::~configNodeStorageNaive()
{
    int i,j;
    for( i=0 ; i<HASH_KEY1_SZ ; i++ )
        for( j=0 ; j<HASH_KEY2_SZ ; j++ )
            delete dt[i][j];
}

bool configNodeStorageNaive::isGPU()
{
    return false;
}

configNode* configNodeStorageNaive::getConfigNode(Graph* g,int rPos,int len,int* vPos)
{
    int vPosSum = 0;
    int vVacSize = 0;
    int vacSize = 0;
    int* vacArr = new int[g->cntNodes()]; // space waste but still
    int i,j;
    for( i=0 ; i<len ; i++ )
    	for( j=0 ; j<INT_BIT_SZ ; j++ )
    		if( (vPos[i] & (1<<j)) != 0 ) {
    			vPosSum += (i*INT_BIT_SZ+j);
    			vacArr[vacSize++] = (i*INT_BIT_SZ+j);
    			vVacSize++;
    		}

    key_ii key(rPos%HASH_KEY1_SZ,vPosSum%HASH_KEY2_SZ);
    linkListIterator tmpList(dt[key.first][key.second]);  // initialize
    configNode* tmpNode;

    bool flag;    // for testing the similarity
    while( tmpList.hasNext() )
    {
        flag = false;       // if true , then dissimilar
        tmpNode = tmpList.next();
        // now check if tmpNode is having the same conf
        if( rPos !=  tmpNode->getRobotPos() )
            flag = true;
        else if ( vVacSize != tmpNode->cntVacant() )
            flag = true;
        else {
            for( i = 0 ; i<vacSize ; i++ )
                if ( tmpNode->isVacant(vacArr[i]) == false )
                {
                	flag = true;
                	break;
                }
        }
        if( flag == false )    // i.e. node found
            return tmpNode;
    }
    delete[] vacArr;

    // new Node needs to be initialized and update the hash DS
    tmpNode = (configNode*)(new configNodeNaive(g,rPos,len,vPos,this));
    dt[key.first][key.second]->insertNode(tmpNode) ;
    return tmpNode;  // return the newly initialized node

}

// The array version of the getConfigNode , vectors are slow
configNode* configNodeStorageNaive::getConfigNode(Graph*g,int rPos,int len,int* vPos)
{
	// First search if such a configuration exist
	key_ii key;

    int vPosSum = 0;
    int i,sz=vPos.size();
    for( i=0 ; i<sz ; i++ )
        vPosSum += vPos[i];

    key_ii key(rPos%HASH_KEY1_SZ,vPosSum%HASH_KEY2_SZ);
    linkListIterator tmpList(dt[key.first][key.second]);  // initialize
    configNode* tmpNode;
    bool flag;    // for testing the similarity
    while( tmpList.hasNext() )
    {
        flag = false;       // if true , then dissimilar
        tmpNode = tmpList.next();
        // now check if tmpNode is having the same conf
        if( rPos !=  tmpNode->getRobotPos() )
            flag = true;
        else if ( vPos.size() != tmpNode->cntVacant() )
            flag = true;
        else {
            for( i = 0 ; i<vPos.size() ; i++ )
                if ( tmpNode->isVacant(vPos[i]) == false )
                {
                	flag = true;
                	break;
                }
        }
        if( flag == false )    // i.e. node found
            return tmpNode;
    }

    // new Node needs to be initialized and update the hash DS
    tmpNode = (configNode*)(new configNodeNaive(g,rPos,vPos,this));
    dt[key.first][key.second]->insertNode(tmpNode) ;
    return tmpNode;  // return the newly initialized node


}

bool configNodeStorageNaive::deleteConfigNode(configNode* ptr)
{
	// first calculate the key for (*ptr)
	key_ii key;
	key.first = (ptr->getRobotPos() % HASH_KEY1_SZ);
	int n=this->graph->cntNodes();

	// TODO: Edit code below
	int tmp=0;			// A temporary variable
	for( int i=1;i<=n;i++ )	{
		if( ptr->isVacant(i)   ) {
			tmp+=i;
		}
	}
	key.second= (tmp % HASH_KEY2_SZ);

	linkListIterator tmpList(dt[key.first][key.second]);  // initialize
	configNode* tmpNode;
	bool flag;    // for testing the similarity
	while( tmpList.hasNext() )
	{
		flag = false;       // if true , then dissimilar
	    tmpNode = tmpList.next();
	    // now check if tmpNode is having the same conf
	    if( ptr->getRobotPos() !=  tmpNode->getRobotPos() )
	    	flag = true;
	    else if ( ptr->cntVacant() != tmpNode->cntVacant() )
	        flag = true;
	    else {
	    	int n = ptr->cntNodes();
	        for( i = 1 ; i<n ; i++ )
	        	if( tmpNode->isVacant(i) == ptr->isVacant(i)  )


	        // TODO: Remove code below this line
	    	for( i = 0 ; i<vPos.size() ; i++ )
	        	if ( tmpNode->isVacant(vPos[i]) == false )
	            {
	              	flag = true;
	               	break;
	            }
	    }
	    if( flag == false )    // i.e. node found
	    	return tmpNode;
	}



